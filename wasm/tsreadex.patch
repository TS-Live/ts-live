diff --git a/.gitignore b/.gitignore
index 0e3f8ce..facb0e6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,3 +12,4 @@
 !.gitignore
 !Makefile
 *.FileListAbsolute.txt
+build/
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..2f7086e
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,18 @@
+cmake_minimum_required(VERSION 3.10)
+project(tsreadex LANGUAGES CXX)
+
+set(CMAKE_CXX_STANDARD 11)
+
+# TODO: -municode when MINGW_PREFIX
+
+set(TSREADEX_LIBRARY_SRC util.cpp id3conv.cpp servicefilter.cpp aac.cpp huffman.cpp traceb24.cpp)
+set(TSREADEX_LIBRARY_HDR util.hpp id3conv.hpp servicefilter.hpp aac.hpp huffman.hpp traceb24.hpp)
+
+add_library(tsreadexlib ${TSREADEX_LIBRARY_SRC} ${TSREADEX_LIBRARY_HDR})
+set_property(TARGET tsreadexlib PROPERTY OUTPUT_NAME tsreadex)
+add_library(tsreadex::lib ALIAS tsreadexlib)
+target_include_directories(tsreadexlib PUBLIC ${PROJECT_SOURCE_DIR})
+export(TARGETS tsreadexlib NAMESPACE tsreadex FILE ${PROJECT_BINARY_DIR}/tsreadex-targets.cmake)
+
+add_executable(tsreadex tsreadex.cpp ${TSREADEX_LIBRARY_SRC})
+
diff --git a/Readme.txt b/Readme.txt
index 4cc82dd..45703c9 100644
--- a/Readme.txt
+++ b/Readme.txt
@@ -56,8 +56,9 @@ tsreadex [-z ignored][-s seek][-l limit][-t timeout][-m mode][-x pids][-n prog_n
   +8のとき、デュアルモノ(ARIB STD-B32)を2つのモノラル音声に分離し、右音声を第2音声として扱う(AACのみ)。
 
 -b aud2, range=0 or 1 or 2 [+4], default=0
-  第2音声をそのままか、補完するか、削除するか。
+  第2音声をそのままか、補完するか、削除するか、第1音声をコピーするか。
   1のとき、ストリームが存在しなければPMTの項目を補って無音のAACストリームを挿入する。
+  3のとき、ストリームが存在しなければ第1音声をコピーする。
   +4のとき、モノラルであればステレオにする(AACのみ)。
 
 -c cap, range=0 or 1 or 2, default=0
diff --git a/servicefilter.cpp b/servicefilter.cpp
index cda1cbc..f75dcc1 100644
--- a/servicefilter.cpp
+++ b/servicefilter.cpp
@@ -129,6 +129,9 @@ void CServiceFilter::AddPacket(const uint8_t *packet)
                     m_isAudio1DualMono = m_audio1MuxDualMono && m_audio1StreamType == ADTS_TRANSPORT && TransmuxDualMono(m_audio1UnitPackets);
                     if (m_isAudio1DualMono || (m_audio1MuxToStereo && m_audio1StreamType == ADTS_TRANSPORT &&
                             TransmuxMonoToStereo(m_audio1UnitPackets, m_audio1MuxWorkspace, 0x0110, m_audio1PesCounter, m_audio1PtsPcrDiff))) {
+                        if (m_audio2Mode == 3 && m_audio2Pid == 0) {
+                            TransmuxMonoToStereo(m_audio1UnitPackets, m_audio1MuxWorkspace, 0x0111, m_audio1PesCounter, m_audio1PtsPcrDiff);
+                        }
                         // Already added
                         m_audio1UnitPackets.clear();
                     }
@@ -143,6 +146,9 @@ void CServiceFilter::AddPacket(const uint8_t *packet)
                         }
                         m_audio1PesCounter = (m_audio1PesCounter + 1) & 0x0f;
                         ChangePidAndAddPacket(packet_, 0x0110, m_audio1PesCounter);
+                        if (m_audio2Mode == 3 && m_audio2Pid == 0) {
+                            ChangePidAndAddPacket(packet_, 0x0111, m_audio1PesCounter);
+                        }
                     }
                     m_audio1UnitPackets.clear();
                 }
@@ -401,7 +407,7 @@ void CServiceFilter::AddPmt(const PSI &psi)
             m_buf[10] = 0x00;
         }
     }
-    bool addAudio2 = m_audio2Pid != 0 || m_audio2Mode == 1 || (m_audio2Mode != 2 && m_isAudio1DualMono);
+    bool addAudio2 = m_audio2Pid != 0 || m_audio2Mode == 1 || m_audio2Mode == 3 || (m_audio2Mode != 2 && m_isAudio1DualMono);
     if (m_audio1Pid != 0 || m_audio1Mode == 1) {
         m_buf.push_back(m_audio1StreamType);
         // PID=0x0110
diff --git a/tsreadex.cpp b/tsreadex.cpp
index afa8bfd..57aef5a 100644
--- a/tsreadex.cpp
+++ b/tsreadex.cpp
@@ -29,107 +29,120 @@
 
 namespace
 {
-void SleepFor(std::chrono::milliseconds rel)
-{
+    void SleepFor(std::chrono::milliseconds rel)
+    {
 #ifdef _WIN32
-    // MSVC sleep_for() is buggy
-    Sleep(static_cast<DWORD>(rel.count()));
+        // MSVC sleep_for() is buggy
+        Sleep(static_cast<DWORD>(rel.count()));
 #else
-    std::this_thread::sleep_for(rel);
+        std::this_thread::sleep_for(rel);
 #endif
-}
+    }
 
 #ifdef _WIN32
-const char *GetSmallString(const wchar_t *s)
-{
-    static char ss[32];
-    size_t i = 0;
-    for (; i < sizeof(ss) - 1 && s[i]; ++i) {
-        ss[i] = 0 < s[i] && s[i] <= 127 ? static_cast<char>(s[i]) : '?';
+    const char *GetSmallString(const wchar_t *s)
+    {
+        static char ss[32];
+        size_t i = 0;
+        for (; i < sizeof(ss) - 1 && s[i]; ++i)
+        {
+            ss[i] = 0 < s[i] && s[i] <= 127 ? static_cast<char>(s[i]) : '?';
+        }
+        ss[i] = '\0';
+        return ss;
     }
-    ss[i] = '\0';
-    return ss;
-}
 
-int64_t SeekFile(HANDLE file, int64_t offset)
-{
-    LARGE_INTEGER li;
-    li.QuadPart = offset < 0 ? offset + 1 : offset;
-    return SetFilePointerEx(file, li, &li, offset < 0 ? FILE_END : FILE_BEGIN) ? li.QuadPart : -1;
-}
+    int64_t SeekFile(HANDLE file, int64_t offset)
+    {
+        LARGE_INTEGER li;
+        li.QuadPart = offset < 0 ? offset + 1 : offset;
+        return SetFilePointerEx(file, li, &li, offset < 0 ? FILE_END : FILE_BEGIN) ? li.QuadPart : -1;
+    }
 
-template<class P>
-int ReadFileToBuffer(HANDLE file, uint8_t *buf, size_t count, HANDLE asyncContext, P asyncCancelProc)
-{
-    OVERLAPPED ol = {};
-    DWORD nRead;
-    if (asyncContext) {
-        ol.hEvent = asyncContext;
-        if (ReadFile(file, buf, static_cast<DWORD>(count), nullptr, &ol)) {
-            return GetOverlappedResult(file, &ol, &nRead, FALSE) ? nRead : -1;
-        }
-        else if (GetLastError() == ERROR_IO_PENDING) {
-            while (!asyncCancelProc()) {
-                if (WaitForSingleObject(asyncContext, 1000) != WAIT_TIMEOUT) {
-                    return GetOverlappedResult(file, &ol, &nRead, FALSE) ? nRead : -1;
+    template <class P>
+    int ReadFileToBuffer(HANDLE file, uint8_t *buf, size_t count, HANDLE asyncContext, P asyncCancelProc)
+    {
+        OVERLAPPED ol = {};
+        DWORD nRead;
+        if (asyncContext)
+        {
+            ol.hEvent = asyncContext;
+            if (ReadFile(file, buf, static_cast<DWORD>(count), nullptr, &ol))
+            {
+                return GetOverlappedResult(file, &ol, &nRead, FALSE) ? nRead : -1;
+            }
+            else if (GetLastError() == ERROR_IO_PENDING)
+            {
+                while (!asyncCancelProc())
+                {
+                    if (WaitForSingleObject(asyncContext, 1000) != WAIT_TIMEOUT)
+                    {
+                        return GetOverlappedResult(file, &ol, &nRead, FALSE) ? nRead : -1;
+                    }
                 }
+                CancelIo(file);
+                WaitForSingleObject(asyncContext, INFINITE);
             }
-            CancelIo(file);
-            WaitForSingleObject(asyncContext, INFINITE);
         }
+        else if (ReadFile(file, buf, static_cast<DWORD>(count), &nRead, nullptr))
+        {
+            return nRead;
+        }
+        return -1;
     }
-    else if (ReadFile(file, buf, static_cast<DWORD>(count), &nRead, nullptr)) {
-        return nRead;
-    }
-    return -1;
-}
 
-void CloseFile(HANDLE file, HANDLE asyncContext)
-{
-    if (file != INVALID_HANDLE_VALUE) {
-        CloseHandle(file);
-    }
-    if (asyncContext) {
-        CloseHandle(asyncContext);
+    void CloseFile(HANDLE file, HANDLE asyncContext)
+    {
+        if (file != INVALID_HANDLE_VALUE)
+        {
+            CloseHandle(file);
+        }
+        if (asyncContext)
+        {
+            CloseHandle(asyncContext);
+        }
     }
-}
 #else
-const char *GetSmallString(const char *s)
-{
-    return s;
-}
+    const char *GetSmallString(const char *s)
+    {
+        return s;
+    }
 
-int64_t SeekFile(int file, int64_t offset)
-{
-    return lseek(file, offset < 0 ? offset + 1 : offset, offset < 0 ? SEEK_END : SEEK_SET);
-}
+    int64_t SeekFile(int file, int64_t offset)
+    {
+        return lseek(file, offset < 0 ? offset + 1 : offset, offset < 0 ? SEEK_END : SEEK_SET);
+    }
 
-template<class P>
-int ReadFileToBuffer(int file, uint8_t *buf, size_t count, bool asyncContext, P asyncCancelProc)
-{
-    for (;;) {
-        int ret = static_cast<int>(read(file, buf, count));
-        if (ret >= 0 || !asyncContext || (errno != EAGAIN && errno != EWOULDBLOCK) || asyncCancelProc()) {
-            return ret;
-        }
-        fd_set rfd;
-        FD_ZERO(&rfd);
-        FD_SET(file, &rfd);
-        timeval tv = {};
-        tv.tv_sec = 1;
-        if (select(file + 1, &rfd, nullptr, nullptr, &tv) < 0) {
-            return -1;
+    template <class P>
+    int ReadFileToBuffer(int file, uint8_t *buf, size_t count, bool asyncContext, P asyncCancelProc)
+    {
+        for (;;)
+        {
+            int ret = static_cast<int>(read(file, buf, count));
+            if (ret >= 0 || !asyncContext || (errno != EAGAIN && errno != EWOULDBLOCK) || asyncCancelProc())
+            {
+                return ret;
+            }
+            fd_set rfd;
+            FD_ZERO(&rfd);
+            FD_SET(file, &rfd);
+            timeval tv = {};
+            tv.tv_sec = 1;
+            if (select(file + 1, &rfd, nullptr, nullptr, &tv) < 0)
+            {
+                return -1;
+            }
         }
     }
-}
 
-void CloseFile(int file, bool asyncContext)
-{
-    static_cast<void>(asyncContext);
-    if (file >= 0) {
-        close(file);
+    void CloseFile(int file, bool asyncContext)
+    {
+        static_cast<void>(asyncContext);
+        if (file >= 0)
+        {
+            close(file);
+        }
     }
-}
 #endif
 }
 
@@ -156,141 +169,177 @@ int main(int argc, char **argv)
     const char *traceName = "";
 #endif
 
-    for (int i = 1; i < argc; ++i) {
+    for (int i = 1; i < argc; ++i)
+    {
         char c = '\0';
         const char *ss = GetSmallString(argv[i]);
-        if (ss[0] == '-' && ss[1] && !ss[2]) {
+        if (ss[0] == '-' && ss[1] && !ss[2])
+        {
             c = ss[1];
         }
-        if (c == 'h') {
+        if (c == 'h')
+        {
             fprintf(stderr, "Usage: tsreadex [-z ignored][-s seek][-l limit][-t timeout][-m mode][-x pids][-n prog_num_or_index][-a aud1][-b aud2][-c cap][-u sup][-r trace][-d flags] src\n");
             return 2;
         }
         bool invalid = false;
-        if (i < argc - 1) {
-            if (c == 'z') {
+        if (i < argc - 1)
+        {
+            if (c == 'z')
+            {
                 ++i;
             }
-            else if (c == 's') {
+            else if (c == 's')
+            {
                 seekOffset = strtoll(GetSmallString(argv[++i]), nullptr, 10);
             }
-            else if (c == 'l') {
+            else if (c == 'l')
+            {
                 limitReadBytesPerSec = static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10) * 1024);
                 invalid = !(0 <= limitReadBytesPerSec && limitReadBytesPerSec <= 32 * 1024 * 1024);
             }
-            else if (c == 't') {
+            else if (c == 't')
+            {
                 timeoutSec = static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10));
                 invalid = !(0 <= timeoutSec && timeoutSec <= 600);
             }
-            else if (c == 'm') {
+            else if (c == 'm')
+            {
                 timeoutMode = static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10));
                 invalid = !(0 <= timeoutMode && timeoutMode <= 2);
             }
-            else if (c == 'x') {
+            else if (c == 'x')
+            {
                 excludePidSet.clear();
                 ++i;
-                for (size_t j = 0; argv[i][j];) {
+                for (size_t j = 0; argv[i][j];)
+                {
                     ss = GetSmallString(argv[i] + j);
                     char *endp;
                     int pid = static_cast<int>(strtol(ss, &endp, 10));
                     excludePidSet.emplace(pid);
                     invalid = !(0 <= pid && pid <= 8191 && ss != endp && (!*endp || *endp == '/'));
-                    if (invalid || !*endp) {
+                    if (invalid || !*endp)
+                    {
                         break;
                     }
                     j += endp - ss + 1;
                 }
             }
-            else if (c == 'n') {
+            else if (c == 'n')
+            {
                 int n = static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10));
                 invalid = !(-256 <= n && n <= 65535);
                 servicefilter.SetProgramNumberOrIndex(n);
             }
-            else if (c == 'a' || c == 'b' || c == 'c' || c == 'u') {
+            else if (c == 'a' || c == 'b' || c == 'c' || c == 'u')
+            {
                 int mode = static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10));
-                if (c == 'a') {
+                if (c == 'a')
+                {
                     invalid = !(0 <= mode && mode <= 13 && mode % 4 <= 1);
                     servicefilter.SetAudio1Mode(mode);
                 }
-                else if (c == 'b') {
-                    invalid = !(0 <= mode && mode <= 6 && mode % 4 <= 2);
+                else if (c == 'b')
+                {
+                    invalid = !(0 <= mode && mode <= 7 && mode % 4 <= 3);
                     servicefilter.SetAudio2Mode(mode);
                 }
-                else {
+                else
+                {
                     invalid = !(0 <= mode && mode <= 2);
-                    if (c == 'c') {
+                    if (c == 'c')
+                    {
                         servicefilter.SetCaptionMode(mode);
                     }
-                    else {
+                    else
+                    {
                         servicefilter.SetSuperimposeMode(mode);
                     }
                 }
             }
-            else if (c == 'r') {
+            else if (c == 'r')
+            {
                 traceName = argv[++i];
             }
-            else if (c == 'd') {
+            else if (c == 'd')
+            {
                 id3conv.SetOption(static_cast<int>(strtol(GetSmallString(argv[++i]), nullptr, 10)));
             }
         }
-        else {
+        else
+        {
             srcName = argv[i];
             invalid = !srcName[0];
         }
-        if (invalid) {
+        if (invalid)
+        {
             fprintf(stderr, "Error: argument %d is invalid.\n", i);
             return 1;
         }
     }
-    if (!srcName[0]) {
+    if (!srcName[0])
+    {
         fprintf(stderr, "Error: not enough arguments.\n");
         return 1;
     }
-    if (timeoutMode == 2) {
-        if (timeoutSec == 0) {
+    if (timeoutMode == 2)
+    {
+        if (timeoutSec == 0)
+        {
             fprintf(stderr, "Error: timeout must not be 0 in non-blocking mode.\n");
             return 1;
         }
-        if (seekOffset != 0) {
+        if (seekOffset != 0)
+        {
             fprintf(stderr, "Error: cannot seek file in non-blocking mode.\n");
         }
     }
 
 #ifdef _WIN32
     bool traceToStdout = traceName[0] == L'-' && !traceName[1];
-    if (!traceToStdout && _setmode(_fileno(stdout), _O_BINARY) < 0) {
+    if (!traceToStdout && _setmode(_fileno(stdout), _O_BINARY) < 0)
+    {
         fprintf(stderr, "Error: _setmode.\n");
         return 1;
     }
     HANDLE asyncContext = nullptr;
-    if (timeoutMode == 2) {
+    if (timeoutMode == 2)
+    {
         asyncContext = CreateEvent(nullptr, TRUE, FALSE, nullptr);
-        if (!asyncContext) {
+        if (!asyncContext)
+        {
             fprintf(stderr, "Error: unexpected.\n");
             return 1;
         }
     }
     HANDLE file;
     HANDLE openedFile = INVALID_HANDLE_VALUE;
-    if (srcName[0] == L'-' && !srcName[1]) {
+    if (srcName[0] == L'-' && !srcName[1])
+    {
         file = GetStdHandle(STD_INPUT_HANDLE);
-        if (asyncContext) {
+        if (asyncContext)
+        {
             file = ReOpenFile(file, GENERIC_READ, FILE_SHARE_READ, FILE_FLAG_OVERLAPPED);
         }
     }
-    else {
+    else
+    {
         file = CreateFileW(srcName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, nullptr, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | (asyncContext ? FILE_FLAG_OVERLAPPED : 0), nullptr);
         openedFile = file;
     }
-    if (file == INVALID_HANDLE_VALUE) {
+    if (file == INVALID_HANDLE_VALUE)
+    {
         fprintf(stderr, "Error: cannot open file.\n");
         CloseFile(openedFile, asyncContext);
         return 1;
     }
-    if (!traceToStdout && traceName[0]) {
+    if (!traceToStdout && traceName[0])
+    {
         traceFile.reset(_wfopen(traceName, L"w"));
-        if (!traceFile) {
+        if (!traceFile)
+        {
             fprintf(stderr, "Warning: cannot open tracefile.\n");
         }
     }
@@ -299,25 +348,32 @@ int main(int argc, char **argv)
     bool asyncContext = timeoutMode == 2;
     int file;
     int openedFile = -1;
-    if (srcName[0] == '-' && !srcName[1]) {
+    if (srcName[0] == '-' && !srcName[1])
+    {
         file = fileno(stdin);
-        if (asyncContext) {
-            if (fcntl(file, F_SETFL, O_NONBLOCK) == -1) {
+        if (asyncContext)
+        {
+            if (fcntl(file, F_SETFL, O_NONBLOCK) == -1)
+            {
                 file = -1;
             }
         }
     }
-    else {
+    else
+    {
         file = open(srcName, O_RDONLY | (asyncContext ? O_NONBLOCK : 0));
         openedFile = file;
     }
-    if (file < 0) {
+    if (file < 0)
+    {
         fprintf(stderr, "Error: cannot open file.\n");
         return 1;
     }
-    if (!traceToStdout && traceName[0]) {
+    if (!traceToStdout && traceName[0])
+    {
         traceFile.reset(fopen(traceName, "w"));
-        if (!traceFile) {
+        if (!traceFile)
+        {
             fprintf(stderr, "Warning: cannot open tracefile.\n");
         }
     }
@@ -325,9 +381,11 @@ int main(int argc, char **argv)
     traceb24.SetFile(traceToStdout ? stdout : traceFile.get());
 
     int64_t filePos = 0;
-    if (seekOffset != 0) {
+    if (seekOffset != 0)
+    {
         filePos = SeekFile(file, seekOffset);
-        if (filePos < 0) {
+        if (filePos < 0)
+        {
             fprintf(stderr, "Error: seek failed.\n");
             CloseFile(openedFile, asyncContext);
             return 1;
@@ -343,120 +401,150 @@ int main(int argc, char **argv)
     auto lastMeasurementTime = lastWriteTime;
     auto limitReadTime = lastWriteTime + std::chrono::seconds(1);
     int64_t limitReadFilePos = filePos;
-    for (;;) {
+    for (;;)
+    {
         // If timeoutMode == 1, read between "next to the syncword (buf[0])" and syncword.
         size_t bufMax = unitSize == 0 ? bufSize : bufSize / unitSize * unitSize - (timeoutMode == 1 ? unitSize - 1 : 0);
-        int n = ReadFileToBuffer(file, buf + bufCount, bufMax - bufCount, asyncContext, [=]() {
-                    return std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - lastWriteTime).count() >= timeoutSec; });
+        int n = ReadFileToBuffer(file, buf + bufCount, bufMax - bufCount, asyncContext, [=]()
+                                 { return std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - lastWriteTime).count() >= timeoutSec; });
         bool retry = false;
         bool completed = false;
         int bufPos = -1;
-        if (timeoutMode == 0) {
+        if (timeoutMode == 0)
+        {
             // Synchronous, normal (may be appended) file/pipe
             retry = n <= 0;
-            if (!retry) {
+            if (!retry)
+            {
                 bufCount += n;
                 filePos += n;
             }
         }
-        else if (timeoutMode == 1) {
+        else if (timeoutMode == 1)
+        {
             // Synchronous, may be preallocated file
-            if (n <= 0) {
+            if (n <= 0)
+            {
                 filePos += bufCount - (unitSize == 0 ? 0 : 1);
                 timeoutMode = 0;
             }
-            else {
+            else
+            {
                 bufCount += n;
-                if (bufCount == static_cast<int>(bufMax)) {
-                    if (unitSize == 0) {
+                if (bufCount == static_cast<int>(bufMax))
+                {
+                    if (unitSize == 0)
+                    {
                         bufPos = resync_ts(buf, bufCount, &unitSize);
-                        if (unitSize == 0) {
+                        if (unitSize == 0)
+                        {
                             retry = true;
                             bufCount = 0;
                             bufPos = -1;
                         }
-                        else {
+                        else
+                        {
                             // Keep bufPos always 0
                             filePos += bufPos + 1;
                             buf[0] = buf[bufPos];
                             bufCount = 1;
                             bufPos = 0;
-                            if (SeekFile(file, filePos) != filePos) {
+                            if (SeekFile(file, filePos) != filePos)
+                            {
                                 fprintf(stderr, "Warning: seek failed.\n");
                                 completed = true;
                             }
                         }
                     }
-                    else {
+                    else
+                    {
                         // Keep bufPos always 0
                         bufPos = resync_ts(buf, bufCount, &unitSize);
-                        if (bufPos != 0) {
+                        if (bufPos != 0)
+                        {
                             retry = true;
                             bufCount = 1;
                             bufPos = 0;
                         }
-                        else {
+                        else
+                        {
                             filePos += bufCount - 1;
                         }
                     }
                 }
             }
         }
-        else {
+        else
+        {
             // Asynchronous, pipe
-            if (n < 0) {
+            if (n < 0)
+            {
                 completed = true;
             }
-            else {
+            else
+            {
                 bufCount += n;
                 filePos += n;
             }
         }
 
-        if (retry) {
+        if (retry)
+        {
             if (timeoutSec == 0 ||
-                std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - lastWriteTime).count() >= timeoutSec) {
+                std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - lastWriteTime).count() >= timeoutSec)
+            {
                 completed = true;
             }
-            else {
+            else
+            {
                 SleepFor(std::chrono::milliseconds(200));
-                if (SeekFile(file, filePos) != filePos) {
+                if (SeekFile(file, filePos) != filePos)
+                {
                     fprintf(stderr, "Warning: seek failed.\n");
                     completed = true;
                 }
             }
         }
 
-        if (bufCount == static_cast<int>(bufMax) || completed) {
-            if (bufPos < 0) {
+        if (bufCount == static_cast<int>(bufMax) || completed)
+        {
+            if (bufPos < 0)
+            {
                 bufPos = resync_ts(buf, bufCount, &unitSize);
             }
-            for (int i = bufPos; i + 188 <= bufCount; i += unitSize) {
-                if (excludePidSet.count(extract_ts_header_pid(buf + i)) == 0) {
+            for (int i = bufPos; i + 188 <= bufCount; i += unitSize)
+            {
+                if (excludePidSet.count(extract_ts_header_pid(buf + i)) == 0)
+                {
                     servicefilter.AddPacket(buf + i);
                 }
             }
-            for (auto it = servicefilter.GetPackets().cbegin(); it != servicefilter.GetPackets().end(); it += 188) {
+            for (auto it = servicefilter.GetPackets().cbegin(); it != servicefilter.GetPackets().end(); it += 188)
+            {
                 traceb24.AddPacket(&*it);
                 id3conv.AddPacket(&*it);
             }
             servicefilter.ClearPackets();
 
             auto nowTime = std::chrono::steady_clock::now();
-            if (++measurementReadCount >= 500) {
+            if (++measurementReadCount >= 500)
+            {
                 // Maximize buffer size
                 bufSize = sizeof(buf);
             }
-            if (std::chrono::duration_cast<std::chrono::seconds>(nowTime - lastMeasurementTime).count() >= 1) {
+            if (std::chrono::duration_cast<std::chrono::seconds>(nowTime - lastMeasurementTime).count() >= 1)
+            {
                 // Decrease/Increase buffer size
-                bufSize = measurementReadCount < 10 ? std::max(bufSize - sizeof(buf) / 8, sizeof(buf) / 8) :
-                                                      std::min(bufSize + sizeof(buf) / 8, sizeof(buf));
+                bufSize = measurementReadCount < 10 ? std::max(bufSize - sizeof(buf) / 8, sizeof(buf) / 8) : std::min(bufSize + sizeof(buf) / 8, sizeof(buf));
                 measurementReadCount = 0;
                 lastMeasurementTime = nowTime;
             }
-            if (!id3conv.GetPackets().empty()) {
-                if (!traceToStdout) {
-                    if (fwrite(id3conv.GetPackets().data(), 1, id3conv.GetPackets().size(), stdout) != id3conv.GetPackets().size()) {
+            if (!id3conv.GetPackets().empty())
+            {
+                if (!traceToStdout)
+                {
+                    if (fwrite(id3conv.GetPackets().data(), 1, id3conv.GetPackets().size(), stdout) != id3conv.GetPackets().size())
+                    {
                         completed = true;
                     }
                 }
@@ -464,28 +552,35 @@ int main(int argc, char **argv)
                 lastWriteTime = std::chrono::steady_clock::now();
             }
             else if (timeoutSec != 0 &&
-                     std::chrono::duration_cast<std::chrono::seconds>(nowTime - lastWriteTime).count() >= timeoutSec) {
+                     std::chrono::duration_cast<std::chrono::seconds>(nowTime - lastWriteTime).count() >= timeoutSec)
+            {
                 completed = true;
             }
-            if (completed) {
+            if (completed)
+            {
                 break;
             }
-            if ((bufPos != 0 || bufCount >= 188) && (bufCount - bufPos) % 188 != 0) {
+            if ((bufPos != 0 || bufCount >= 188) && (bufCount - bufPos) % 188 != 0)
+            {
                 std::copy(buf + bufPos + (bufCount - bufPos) / 188 * 188, buf + bufCount, buf);
             }
             bufCount = (bufCount - bufPos) % 188;
         }
 
-        if (limitReadBytesPerSec != 0) {
-            if (filePos - limitReadFilePos > limitReadBytesPerSec) {
+        if (limitReadBytesPerSec != 0)
+        {
+            if (filePos - limitReadFilePos > limitReadBytesPerSec)
+            {
                 // Too fast
                 auto nowTime = std::chrono::steady_clock::now();
-                if (limitReadTime > nowTime) {
+                if (limitReadTime > nowTime)
+                {
                     SleepFor(std::chrono::duration_cast<std::chrono::milliseconds>(limitReadTime - nowTime));
                 }
             }
             auto nowTime = std::chrono::steady_clock::now();
-            if (nowTime >= limitReadTime) {
+            if (nowTime >= limitReadTime)
+            {
                 limitReadTime = nowTime + std::chrono::seconds(1);
                 limitReadFilePos = filePos;
             }
